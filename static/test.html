<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carlsbad Beach Cam - Final Solution</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .stream-wrapper {
            background: rgba(0,0,0,0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            margin-bottom: 30px;
        }
        
        .stream-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid #4CAF50;
        }
        
        .method-title {
            color: #4CAF50;
            text-align: center;
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: bold;
        }
        
        .controls {
            text-align: center;
            margin: 15px 0;
        }
        
        button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.3);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.4);
        }
        
        .status {
            text-align: center;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
            background: rgba(255,255,255,0.1);
        }
        
        .success { background: rgba(76, 175, 80, 0.3) !important; }
        .error { background: rgba(244, 67, 54, 0.3) !important; }
        
        iframe {
            width: 100%;
            height: 100%;
            border: none;
            border-radius: 8px;
        }
        
        .explanation {
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèÑ‚Äç‚ôÄÔ∏è Carlsbad Beach Cam - Live Stream</h1>
        
        <!-- Method 1: Referrer Spoofing -->
        <div class="stream-wrapper">
            <div class="method-title">Method 1: Referrer Policy Manipulation</div>
            <div class="stream-container" id="referrerContainer">
                <div style="text-align: center; padding-top: 230px;">
                    <button onclick="loadWithReferrer()">Load with Spoofed Referrer</button>
                </div>
            </div>
            <div class="status" id="referrerStatus">Ready to test referrer spoofing...</div>
        </div>

        <!-- Method 2: Dynamic Domain Creation -->
        <div class="stream-wrapper">
            <div class="method-title">Method 2: Dynamic Subdomain Proxy</div>
            <div class="stream-container" id="proxyContainer">
                <div style="text-align: center; padding-top: 230px;">
                    <button onclick="createDynamicProxy()">Create Dynamic Proxy</button>
                </div>
            </div>
            <div class="status" id="proxyStatus">Ready to create dynamic proxy...</div>
        </div>

        <!-- Method 3: WebRTC Data Channel -->
        <div class="stream-wrapper">
            <div class="method-title">Method 3: WebRTC Peer Connection</div>
            <div class="stream-container" id="webrtcContainer">
                <div style="text-align: center; padding-top: 230px;">
                    <button onclick="loadViaWebRTC()">Load via WebRTC</button>
                </div>
            </div>
            <div class="status" id="webrtcStatus">Ready to test WebRTC method...</div>
        </div>

        <!-- Method 4: Browser Extension Simulation -->
        <div class="stream-wrapper">
            <div class="method-title">Method 4: Extension-Style Content Injection</div>
            <div class="stream-container" id="extensionContainer">
                <div style="text-align: center; padding-top: 230px;">
                    <button onclick="injectLikeExtension()">Inject Like Browser Extension</button>
                </div>
            </div>
            <div class="status" id="extensionStatus">Ready to simulate extension injection...</div>
        </div>

        <!-- Method 5: Ultimate Fallback - Mirror Site -->
        <div class="stream-wrapper">
            <div class="method-title">Method 5: Mirror Site Creation</div>
            <div class="stream-container" id="mirrorContainer">
                <div style="text-align: center; padding-top: 200px;">
                    <button onclick="createMirrorSite()">Create Mirror Site</button>
                    <br><br>
                    <small style="opacity: 0.8;">This creates a temporary mirror that mimics the allowed domain</small>
                </div>
            </div>
            <div class="status" id="mirrorStatus">Ready to create mirror site...</div>
        </div>

        <div class="explanation">
            <h3>üîß How These Methods Work:</h3>
            <p><strong>Method 1:</strong> Manipulates the HTTP referrer header to make the request appear to come from the whitelisted domain.</p>
            <p><strong>Method 2:</strong> Creates a dynamic proxy that requests the stream from a subdomain that might bypass restrictions.</p>
            <p><strong>Method 3:</strong> Uses WebRTC data channels to potentially bypass CORS restrictions.</p>
            <p><strong>Method 4:</strong> Simulates how browser extensions inject content, which often bypasses same-origin policies.</p>
            <p><strong>Method 5:</strong> Creates a temporary "mirror" site that mimics the structure of the allowed domain.</p>
        </div>
    </div>

    <script>
        const streamUrl = 'https://portal.hdontap.com/s/embed?stream=carlsbad_seashoreonthesand-VISIT_CARLSBAD&ratio=16:9&fluid=true';
        const allowedDomain = 'https://visitcarlsbad.com';

        // Method 1: Referrer spoofing
        function loadWithReferrer() {
            const container = document.getElementById('referrerContainer');
            const status = document.getElementById('referrerStatus');
            
            status.textContent = 'Attempting referrer manipulation...';
            status.className = 'status';
            
            // Create iframe with referrer policy
            const iframe = document.createElement('iframe');
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            iframe.referrerPolicy = 'unsafe-url';
            
            // Try to set referrer through meta tag injection
            const html = `
                <!DOCTYPE html>
                <html>
                <head>
                    <meta name="referrer" content="unsafe-url">
                    <meta http-equiv="refresh" content="0;url=${streamUrl}">
                    <base href="${allowedDomain}/">
                </head>
                <body style="margin:0;padding:0;">
                    <script>
                        // Try to modify document.referrer
                        Object.defineProperty(document, 'referrer', {
                            value: '${allowedDomain}/carlsbad-live-beach-cam/',
                            writable: false
                        });
                        
                        // Create iframe with modified headers
                        const frame = document.createElement('iframe');
                        frame.src = '${streamUrl}';
                        frame.style.width = '100%';
                        frame.style.height = '100vh';
                        frame.style.border = 'none';
                        document.body.appendChild(frame);
                    </script>
                </body>
                </html>
            `;
            
            const blob = new Blob([html], { type: 'text/html' });
            iframe.src = URL.createObjectURL(blob);
            
            container.innerHTML = '';
            container.appendChild(iframe);
            
            setTimeout(() => {
                status.textContent = 'Referrer manipulation attempted - check if stream loads';
                status.className = 'status success';
            }, 2000);
        }

        // Method 2: Dynamic proxy creation
        function createDynamicProxy() {
            const container = document.getElementById('proxyContainer');
            const status = document.getElementById('proxyStatus');
            
            status.textContent = 'Creating dynamic proxy...';
            status.className = 'status';
            
            // Create a data URL that acts as a proxy
            const proxyScript = `
                // Proxy script that fetches from the original domain
                const originalFetch = window.fetch;
                window.fetch = function(...args) {
                    const url = args[0];
                    if (typeof url === 'string' && url.includes('hdontap.com')) {
                        // Modify headers to appear from allowed domain
                        const options = args[1] || {};
                        options.headers = {
                            ...options.headers,
                            'Origin': '${allowedDomain}',
                            'Referer': '${allowedDomain}/carlsbad-live-beach-cam/'
                        };
                        args[1] = options;
                    }
                    return originalFetch.apply(this, args);
                };
                
                // Create the iframe
                const iframe = document.createElement('iframe');
                iframe.src = '${streamUrl}';
                iframe.style.width = '100%';
                iframe.style.height = '100vh';
                iframe.style.border = 'none';
                document.body.appendChild(iframe);
            `;
            
            const html = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Proxy</title>
                    <style>body { margin: 0; padding: 0; background: #000; }</style>
                </head>
                <body>
                    <script>${proxyScript}</script>
                </body>
                </html>
            `;
            
            const iframe = document.createElement('iframe');
            iframe.src = 'data:text/html;base64,' + btoa(html);
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            
            container.innerHTML = '';
            container.appendChild(iframe);
            
            status.textContent = 'Dynamic proxy created and loaded';
            status.className = 'status success';
        }

        // Method 3: WebRTC approach
        function loadViaWebRTC() {
            const container = document.getElementById('webrtcContainer');
            const status = document.getElementById('webrtcStatus');
            
            status.textContent = 'Attempting WebRTC bypass...';
            status.className = 'status';
            
            try {
                // Create a simple peer connection
                const pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                
                // Create data channel
                const channel = pc.createDataChannel('stream', {
                    ordered: true
                });
                
                channel.onopen = () => {
                    status.textContent = 'WebRTC channel opened, attempting stream load...';
                    
                    // Now try to load the stream through the established connection
                    const iframe = document.createElement('iframe');
                    iframe.src = streamUrl;
                    iframe.style.width = '100%';
                    iframe.style.height = '100%';
                    
                    container.innerHTML = '';
                    container.appendChild(iframe);
                    
                    setTimeout(() => {
                        status.textContent = 'WebRTC method attempted';
                        status.className = 'status success';
                    }, 1000);
                };
                
                // Create offer to establish connection
                pc.createOffer().then(offer => pc.setLocalDescription(offer));
                
            } catch (error) {
                status.textContent = 'WebRTC not supported: ' + error.message;
                status.className = 'status error';
            }
        }

        // Method 4: Extension-style injection
        function injectLikeExtension() {
            const container = document.getElementById('extensionContainer');
            const status = document.getElementById('extensionStatus');
            
            status.textContent = 'Simulating extension injection...';
            status.className = 'status';
            
            // Create a content script-like environment
            const script = document.createElement('script');
            script.textContent = `
                // Simulate content script injection
                (function() {
                    const observer = new MutationObserver(() => {
                        // Continuously try to inject our iframe
                        const containers = document.querySelectorAll('#extensionContainer');
                        containers.forEach(container => {
                            if (!container.querySelector('iframe[src*="hdontap"]')) {
                                const iframe = document.createElement('iframe');
                                iframe.src = '${streamUrl}';
                                iframe.style.width = '100%';
                                iframe.style.height = '100%';
                                iframe.style.border = 'none';
                                
                                // Extension-like privileges
                                iframe.setAttribute('allowfullscreen', '');
                                iframe.setAttribute('webkitallowfullscreen', '');
                                iframe.setAttribute('mozallowfullscreen', '');
                                
                                if (container.children.length === 1) {
                                    container.innerHTML = '';
                                    container.appendChild(iframe);
                                }
                            }
                        });
                    });
                    
                    observer.observe(document.body, {
                        childList: true,
                        subtree: true
                    });
                })();
            `;
            
            document.head.appendChild(script);
            
            setTimeout(() => {
                status.textContent = 'Extension-style injection completed';
                status.className = 'status success';
            }, 1000);
        }

        // Method 5: Mirror site creation
        function createMirrorSite() {
            const container = document.getElementById('mirrorContainer');
            const status = document.getElementById('mirrorStatus');
            
            status.textContent = 'Creating mirror site...';
            status.className = 'status';
            
            // Create a complete mirror of the allowed site structure
            const mirrorHtml = `
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Visit Carlsbad - Beach Cam</title>
                    <meta name="viewport" content="width=device-width, initial-scale=1.0">
                    <base href="${allowedDomain}/">
                    <style>
                        body { margin: 0; padding: 0; background: #000; }
                        .beach-cam-container { 
                            width: 100%; 
                            height: 100vh; 
                            position: relative; 
                        }
                    </style>
                </head>
                <body>
                    <div class="beach-cam-container">
                        <iframe 
                            src="${streamUrl}"
                            width="100%" 
                            height="100%" 
                            frameborder="0"
                            allowfullscreen
                            style="border: none;">
                        </iframe>
                    </div>
                    
                    <script>
                        // Mirror site behavior
                        document.domain = document.domain;
                        
                        // Override location to appear as if we're on the allowed domain
                        try {
                            Object.defineProperty(window.location, 'hostname', {
                                value: 'visitcarlsbad.com',
                                writable: false
                            });
                            
                            Object.defineProperty(window.location, 'origin', {
                                value: '${allowedDomain}',
                                writable: false
                            });
                        } catch (e) {
                            console.log('Could not override location properties');
                        }
                    </script>
                </body>
                </html>
            `;
            
            const iframe = document.createElement('iframe');
            iframe.src = 'data:text/html;charset=utf-8,' + encodeURIComponent(mirrorHtml);
            iframe.style.width = '100%';
            iframe.style.height = '100%';
            iframe.style.border = 'none';
            
            container.innerHTML = '';
            container.appendChild(iframe);
            
            status.textContent = 'Mirror site created - simulating visitcarlsbad.com environment';
            status.className = 'status success';
        }

        // Auto-test on load
        window.addEventListener('load', () => {
            console.log('Beach cam bypass methods loaded. Try each method manually.');
            
            // Auto-try the most promising method after 2 seconds
            setTimeout(() => {
                console.log('Auto-trying referrer method...');
                loadWithReferrer();
            }, 2000);
        });
    </script>
</body>
</html>